Задача заставила освоить стримы и лямбды, которые помогли решить ее правильно и с меньшим количеством кода.
Итак:
1. В конструкторе Advertisement делаем проверку на ноль 
amountPerOneDisplaying = hits>0 ? initialAmount/hits : 0;

2.Создаем коллекцию списков 
List<List<Advertisement>>
 и 3 вспомогательных метода, которые с этой коллекцией будут работать. 
Два метода вычисляют суммарное время и суммарную стоимость за показ соответственно.
Например 
return list.stream().mapToInt(o->o.getDuration()).sum();
return list.stream().mapToLong(o->o.getAmountPerOneDisplaying()).sum();

Третий метод checkList проверяет с помощью первых двух передаваемые в него списки чтобы суммарное время роликов не превышало время заказа, а также отсеивает списки роликов с прайсом меньшим предидущего переданного, если проверку проходит, то добавляет в коллекцию списков. Это позволяет значительно сократить количество перерабатываемых списков в дальнейших сортировках.
3. Далее создаем рекурсивный метод, который генерирует комбинации(списки) роликов, проверяя описаными выше методами. (посмотритезадачу о рюкзаке)
4. В processVideos Получаем из хранилища список доступных роликов, фильтруем стримом на не превышение роликом времени заказа и наличия hits 
videos.stream()
                .filter(advertisement->advertisement.getDuration()<=timeSeconds)
                .filter(advertisement ->advertisement.getAmountPerOneDisplaying()>0)

Полученный список передаем в наш рекусивный метод, который заполнит нашу коллекцию списков
валидными вариантами.


После чего сортируем с реверсом нашу коллекцию по прайсу за показ, фильтруем по первому самому дорогому списку
allCombinations = allCombinations.stream()
                 .filter(advertisements -> calcDuration(advertisements) == filterMaxDuration)
                 .collect(Collectors.toList());

. Запихиваем обратно в нее же списки с одинаковым прайсом.
Снова сортируем по длительности, фильтруем и запихиваем обратно в коллекцию. Каждый раз проверяя не остался ли список в коллекции один
Наконец сортируем по количеству роликов в списках согласно заданию и получаем нужный нам список.
bestCombination.stream().sorted(
             Comparator.comparingLong(Advertisement::getAmountPerOneDisplaying).reversed()
             .thenComparingLong(a->a.getAmountPerOneDisplaying()/a.getDuration()))


            
Далее этот список сортируем по цене и единственным(кроме рекурсивного) циклом  
вываливаем это все клиенту через консоль.

-------------------------------------------------------------------------------
Не знаю с чего начать... Пожалуй начну с конца.
Вот мой gitHub, там я оставил свой вариант всего класса AdvertisementManager который валидатор не принимал ни в какую по пунктам 4 и 5 и закомментил вариант который с трудом нашёл что бы валидатор это принял. Не знаю почему в итоге мой вариант ему не понравился но я потратил 33 попытки что бы он принял в итоге чужой код. Всё вроде работало, тестил на всяких "неудобных" вариантох что про проконтролировать как работает тот или иной метод. 
    В поисках "что хочет валидатор" тут обшарил все комменты - бесполезно. В итоге вычислил что слегка изменив конструктор 
public AdvertisementManager(int timeSeconds) {
    this.timeSeconds = timeSeconds * 60;
}
что бы не передавать в него время всё время умножая на 60, так эта падла сразу забраковала 1 и 2 пункт (когда удалил это " * 60 " и умножал там где вызывается конструктор, то сразу эти пункты принял). Так же пытался убирать все добавленные мной поля/методы по всем местам в надежде что так же проканает, но нет.
   Короче в итоге как принял валидатор:
- класс AdvertisementManager в том виде как тут с учётом поправок из комментариев (или как с моего git, там указал что брать, а что нет). Что не мало важно (как я понял и сделал) это сделать проверку getHits() > 0 (делал в самом методе processVideos(). Для этого добавил в класс Advertisement обычный getHits();
- игрался по советам nen с методом createOrder() в Tablet, но вроде почти так же всё и оставил (если что - вам на git);

- в Advertisement переопределить toString() что бы вывод был как из 9-го задания в примере
Пример для заказа [Water]:
First Video is displaying... 50, 277
где First Video - название рекламного ролика
где 50 - стоимость показа одного рекламного ролика в копейках
где 277 - стоимость показа одной секунды рекламного ролика в тысячных частях копейки (равно 0.277 коп)
и вызывать его где нужно (у меня было немножко наоборот - без toString() );
- обязательно выполнить проверку в конструкторе Advertisement 
amountPerOneDisplaying = hits > 0 ? initialAmount / hits : 0;

Так вроде всё. Были конечно ещё моменты у меня, но я их как добавлял, так и удалил.

Пока буду делать дальше со своим вариантом AdvertisementManager, и если с ним будут проблемы, то вернусь сюда и напишу. Если не напишу, то значит со своим вариантом так и сдал крайнее задание.
